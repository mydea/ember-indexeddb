<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>addon/services/indexed-db.js - ember-indexeddb</title>
    <meta name="description" content="A utility for using IndexedDB with ember &amp; ember-data">
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="stylesheet" href="../assets/css/custom.css">
    <link rel="stylesheet" href="../assets/vendor/bootstrap/css/bootstrap.css">
    <link rel="stylesheet" href="../assets/vendor/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="../assets/css/theme.css">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:300,400,500,600,700' rel='stylesheet' type='text/css'>
    

</head>
<body>
    <nav class="navbar navbar-default">
      <div class="container-fluid">
        <div class="navbar-header">
          <a href="../" class="navbar-brand">
              <img src="../assets/img/ember-logo.png" alt="enterprise logo">
            <span>indexeddb</span>
          </a>
        </div>

        <div class="collapse navbar-collapse" id="nav">
          <ul class="nav navbar-nav navbar-right">
            <li><a href="https://github.com/mydea/ember-indexeddb" class="fa fa-github github"></a></li>
          </ul>
        </div>
      </div>
    </nav>
    <div id="main-wrapper" class="row">
        <div id="content-wrapper">
            <ol class="panel-group" id="sidebar" role="tablist" aria-multiselectable="true">
                <li class="panel panel-default">
                    <div class="panel-heading" role="tab" id="sidebar-search-heading">
                        <h4 class="panel-title">
                      <a role="button" data-toggle="collapse" href="#sidebar-search" aria-expanded="true" aria-controls="collapseOne">
                        Search
                      </a>
                    </h4>
                    </div>
                    <div id="sidebar-search" class="panel-collapse collapse in" role="tabpanel" aria-labelledby="sidebar-search-heading">
                        <div class="panel-body">
                            <div id="api-tabview-filter">
                                <input type="search" id="api-filter" placeholder="Search...">
                            </div>
                        </div>
                    </div>
                </li>
                    <li class="panel panel-default">
                        <div class="panel-heading" role="tab" id="sidebar-version-heading">
                            <h4 class="panel-title">
                                <a role="button" href="https://github.com/mydea/ember-indexeddb/commits/v3.0.0-beta.1" target="_blank">
                                  Tag: v3.0.0-beta.1
                                </a>
                            </h4>
                        </div>
                    </li>
                <li class="panel panel-default">
                    <div class="panel-heading" role="tab" id="sidebar-modules-heading">
                        <h4 class="panel-title">
                    <a role="button" data-toggle="collapse" href="#sidebar-modules" aria-expanded="true" aria-controls="collapseOne">
                      Modules
                    </a>
                  </h4>
                    </div>
                    <div id="sidebar-modules" class="panel-collapse collapse in" role="tabpanel" aria-labelledby="sidebar-modules-heading">
                        <div class="panel-body">
                                <ol>
                                        <li>
                                            <a href="../modules/Ember Data.html">Ember Data</a>
                                        </li>
                                        <li>
                                            <a href="../modules/Services.html">Services</a>
                                        </li>
                                        <li>
                                            <a href="../modules/Test Helpers.html">Test Helpers</a>
                                        </li>
                                        <li>
                                            <a href="../modules/Usage.html">Usage</a>
                                                    <li class="sub"><a href="../modules/Setup.html">Setup</a></li>
                                                    <li class="sub"><a href="../modules/Configuring your database.html">Configuring your database</a></li>
                                                    <li class="sub"><a href="../modules/Querying &amp; Inserting data.html">Querying &amp; Inserting data</a></li>
                                        </li>
                                        <li>
                                            <a href="../modules/Utils.html">Utils</a>
                                        </li>
                                </ol>
                        </div>
                    </div>
                </li>
            
                <li class="panel panel-default">
                    <div class="panel-heading" role="tab" id="sidebar-classes-heading">
                        <h4 class="panel-title">
                      <a role="button" data-toggle="collapse" href="#sidebar-classes" aria-expanded="true" aria-controls="collapseOne">
                        Classes
                      </a>
                    </h4>
                    </div>
                    <div id="sidebar-classes" class="panel-collapse collapse in" role="tabpanel" aria-labelledby="sidebar-classes-heading">
                        <div class="panel-body">
                            <ol>
                                    <li>
                                        <a href="../classes/IndexedDb.html">IndexedDb</a>
                                    </li>
                                    <li>
                                        <a href="../classes/IndexedDbAdapter.html">IndexedDbAdapter</a>
                                    </li>
                                    <li>
                                        <a href="../classes/IndexedDbConfiguration.html">IndexedDbConfiguration</a>
                                    </li>
                                    <li>
                                        <a href="../classes/IndexedDbSerializer.html">IndexedDbSerializer</a>
                                    </li>
                                    <li>
                                        <a href="../classes/ModelBulkSave.html">ModelBulkSave</a>
                                    </li>
                                    <li>
                                        <a href="../classes/ModelBulkSaver.html">ModelBulkSaver</a>
                                    </li>
                            </ol>
                        </div>
                    </div>
                </li>
            </ol>
            <div class="content-container">
                <div class="apidocs">
                    <div id="docs-main">
                        <div class="content">
<div class="page-header">
    <h1><i class="fa fa-file-code-o" aria-hidden="true"></i>  File</h1>
</div>

<div class="file">
    <pre class="prettyprint linenums">
import Service, { inject as service } from &#x27;@ember/service&#x27;;
import { set } from &#x27;@ember/object&#x27;;
import { Promise } from &#x27;rsvp&#x27;;
import { later } from &#x27;@ember/runloop&#x27;;
import { typeOf as getTypeOf } from &#x27;@ember/utils&#x27;;
import { A as array } from &#x27;@ember/array&#x27;;
import { task, timeout } from &#x27;ember-concurrency&#x27;;
import Dexie from &#x27;dexie&#x27;;
import { buildWaiter, waitForPromise } from &#x27;@ember/test-waiters&#x27;;
import { macroCondition, isTesting } from &#x27;@embroider/macros&#x27;;

const testWaiter = buildWaiter(&#x27;ember-indexeddb&#x27;);

/**
 * This service allows interacting with an IndexedDB database.
 *
 * @module Services
 * @class IndexedDb
 * @extends Ember.Service
 * @public
 */
export default class IndexedDbService extends Service {
  @service store;
  @service indexedDbConfiguration;

  /**
   * The actual Dexie database.
   *
   * @property db
   * @type {Dexie}
   * @public
   */
  db;

  /**
   * The database name to use.
   * Overwrite this if you want to use something different.
   *
   * @property databaseName
   * @type {String}
   * @default &#x27;ember-indexeddb&#x27;
   * @public
   */
  databaseName = &#x27;ember-indexeddb&#x27;;

  /**
   * If set to true, it will output which indecies are used for queries.
   * This can be used to debug your indecies.
   *
   * @property _shouldLogQuery
   * @type {Boolean}
   * @default false
   * @private
   */
  _shouldLogQuery = false;

  /**
   * This is an object with an array per model type.
   * It holds all the objects per model type that should be bulk saved.
   * After actually saving, this will be cleared.
   *
   * @property _saveQueue
   * @type {Object}
   * @private
   */
  _saveQueue = {};

  /**
   * This is the test waiter used to ensure all promises are resolved in tests.
   * This is set by the this._registerTestWaiter() method.
   *
   * @property _testWaiter
   * @type {Function}
   * @private
   */
  _testWaiter;

  /**
   * This is a promise that is used for bulk saving.
   * All bulkSave() operations use and return the same promise, which is cached here.
   *
   * @property _savePromise
   * @type {Promise}
   * @private
   */
  _savePromise;

  /**
   * All currently running promises are temporarily saved here.
   * This is used to check if there are running transactions.
   *
   * @property _promiseQueue
   * @type {Promise[]}
   * @private
   */
  _promiseQueue = array();

  /**
   * e.g. MS Edge doesn&#x27;t support compound indices.
   * For these cases, querying shouldn&#x27;t try to use them.
   *
   * @property _supportsCompoundIndicies
   * @type {Boolean}
   * @readOnly
   * @private
   */
  _supportsCompoundIndices = true;

  /**
   * Call this and wait until it resolves before doing anything with IndexedDB!
   * This should be done in beforeModel() on the application route.
   * It will reject if IndexedDB is not available.
   *
   * Also available as a task: &#x60;indexedDb.setupTask.perform()&#x60;
   *
   * @method setup
   * @return {Promise}
   * @public
   */
  setup() {
    this.setupTask.perform();
  }

  @task(function* () {
    if (this.db) {
      return this.db;
    }

    let testWaiterToken = testWaiter.beginAsync();

    let db = new Dexie(this.databaseName);

    let { indexedDbConfiguration } = this;
    indexedDbConfiguration.setupDatabase(db);

    set(this, &#x27;db&#x27;, db);

    yield openDb(db);

    testWaiter.endAsync(testWaiterToken);

    return db;
  })
  setupTask;

  /**
   * Query indexedDB.
   * This uses _buildQuery under the hood.
   * This resolved to an array.
   *
   * @method query
   * @param {String} type The model type to query
   * @param {Object} query The query data
   * @return {Promise[]}
   * @public
   */
  query(type, query) {
    let queryPromise = this._buildQuery(type, query);
    let promise = new Promise(
      (resolve, reject) =&gt; queryPromise.toArray().then(resolve, reject),
      &#x27;indexedDb/query&#x27;
    );

    this._addToPromiseQueue(promise);
    return promise;
  }

  /**
   * Query indexedDB.
   * This uses _buildQuery under the hood.
   * This resolved to an object.
   *
   * @method queryRecord
   * @param {String} type The model type to query
   * @param {Object} query The query data
   * @return {Promise}
   * @public
   */
  queryRecord(type, query) {
    let queryPromise = this._buildQuery(type, query);

    let promise = new Promise(
      (resolve, reject) =&gt; queryPromise.first().then(resolve, reject),
      &#x27;indexedDb/queryRecord&#x27;
    );

    this._addToPromiseQueue(promise);
    return promise;
  }

  /**
   * Find one or multiple items by id.
   * If id is an array, this will try to fetch all of these objects and resolve with an array.
   * Otherwise, it will resolve with an object.
   *
   * @method find
   * @param {String} type The model type to find
   * @param {String|String[]} id One or multiple ids to fetch
   * @return {Promise}
   * @public
   */
  find(type, id) {
    let { db } = this;

    if (getTypeOf(id) === &#x27;array&#x27;) {
      return db[type].where(&#x27;id&#x27;).anyOf(id.map(this._toString)).toArray();
    }

    let promise = new Promise(
      (resolve, reject) =&gt;
        db[type].get(this._toString(id)).then(resolve, reject),
      &#x27;indexedDb/find&#x27;
    );

    this._addToPromiseQueue(promise);
    return promise;
  }

  /**
   * Find all of a given type.
   *
   * @method findAll
   * @param {String} type The model type to find.
   * @return {Promise}
   * @public
   */
  findAll(type) {
    let { db } = this;

    let promise = new Promise(
      (resolve, reject) =&gt; db[type].toArray().then(resolve, reject),
      &#x27;indexedDb/findAll&#x27;
    );

    this._addToPromiseQueue(promise);
    return promise;
  }

  /**
   * Add one or multiple items to the database.
   *
   * @method add
   * @param {String} type The model type to add
   * @param {Object|Object[]} items One or multiple objects to add to the database.
   * @return {Promise}
   * @public
   */
  add(type, items) {
    let { db } = this;

    // Single Item?
    if (getTypeOf(items) !== &#x27;array&#x27;) {
      items = array([items]);
    }

    let data = items.map((item) =&gt; {
      return this._mapItem(type, item);
    });

    let promise = new Promise(
      (resolve, reject) =&gt; db[type].bulkPut(data).then(resolve, reject),
      &#x27;indexedDb/add&#x27;
    );

    this._addToPromiseQueue(promise);
    return promise;
  }

  /**
   * Save/update an item.
   *
   * @method save
   * @param {String} type The model type of the object
   * @param {String} id The id of the object
   * @param {Object} item The serialized object to save.
   * @return {Promise}
   * @public
   */
  save(type, id, item) {
    let { db } = this;

    let data = this._mapItem(type, item);
    let promise = new Promise(
      (resolve, reject) =&gt; db[type].put(data).then(resolve, reject),
      &#x27;indexedDb/save&#x27;
    );

    this._addToPromiseQueue(promise);
    return promise;
  }

  /**
   * This will wait for 10ms and try to build a queue, and save everything at once if possible.
   *
   * @method saveBulk
   * @param {String} type The model type to save
   * @param {Object} item The data to save
   * @return {Promise}
   * @public
   */
  saveBulk(type, item) {
    let { _savePromise: savePromise, _saveQueue: saveQueue } = this;

    // If no save promise exists, create a new one
    if (!savePromise) {
      savePromise = new Promise((resolve, reject) =&gt; {
        later(
          this,
          () =&gt; {
            this._bulkSave().then((val) =&gt; {
              set(this, &#x27;_savePromise&#x27;, null);
              resolve(val);
            }, reject);
          },
          100
        );
      }, &#x27;indexedDb/saveBulk&#x27;);
      set(this, &#x27;_savePromise&#x27;, savePromise);
      this._addToPromiseQueue(savePromise);
    }

    let queue = saveQueue[type];
    if (!queue) {
      queue = array();
      saveQueue[type] = queue;
    }

    queue.pushObject(item);
    return savePromise;
  }

  /**
   * Clear a database table.
   *
   * @method clear
   * @param {String} type The model type to clear.
   * @return {Promise}
   * @public
   */
  clear(type) {
    let { db } = this;

    let promise = new Promise(
      (resolve, reject) =&gt; db[type].clear().then(resolve, reject),
      &#x27;indexedDb/clear&#x27;
    );

    this._addToPromiseQueue(promise);
    return promise;
  }

  /**
   * Delete one item.
   *
   * @method delete
   * @param {String} type The model type to delete
   * @param {String} id The id of the entry to delete
   * @return {Promise}
   * @public
   */
  delete(type, id) {
    let { db } = this;

    let promise = new Promise(
      (resolve, reject) =&gt; db[type].delete(id).then(resolve, reject),
      &#x27;indexedDb/delete&#x27;
    );

    this._addToPromiseQueue(promise);
    return promise;
  }

  /**
   * Drop the entire database.
   *
   * Also available as a task: &#x60;indexedDb.dropDatabaseTask.perform()&#x60;
   *
   * @method dropDatabase
   * @return {Promise}
   * @public
   */
  dropDatabase() {
    return this.dropDatabaseTask.perform();
  }

  @task(function* () {
    let { db } = this;

    if (!db) {
      return;
    }

    let testWaiterToken = testWaiter.beginAsync();

    // Ensure the db is open
    yield openDb(db);
    yield this.waitForQueueTask.perform();
    yield timeout(100);
    yield db.delete();
    yield closeDb(db);

    set(this, &#x27;db&#x27;, null);

    testWaiter.endAsync(testWaiterToken);
  })
  dropDatabaseTask;

  /**
   * Export a complete dump of the current database.
   * The output of this can be used to recreate the exact database state via this.importDatabase(config);
   *
   * Also available as a task: &#x60;indexedDb.exportDatabaseTask.perform()&#x60;
   *
   * @method exportDatabase
   * @return {Promise}
   * @public
   */
  exportDatabase() {
    let promise = this.exportDatabaseTask.perform();
    this._addToPromiseQueue(promise);
    return promise;
  }

  @task(function* () {
    let { db, databaseName, currentVersion: version } = this;

    let config = {
      databaseName,
      version,
      stores: {},
      data: {},
    };

    // Now, open database without specifying any version. This will make the database open any existing database and read its schema automatically.
    yield openDb(db);

    // Save the last version number
    set(config, &#x27;version&#x27;, db.verno);

    let promises = array();

    db.tables.forEach(function (table) {
      let primKeyAndIndexes = [table.schema.primKey].concat(
        table.schema.indexes
      );
      let schemaSyntax = primKeyAndIndexes
        .map(function (index) {
          return index.src;
        })
        .join(&#x27;,&#x27;);

      set(config.stores, table.name, schemaSyntax);

      let promise = table.each((object) =&gt; {
        let arr = config.data[table.name];

        if (!arr) {
          arr = array();
          set(config.data, table.name, arr);
        }

        arr.push(object);
      });

      promises.push(promise);
    });

    yield Promise.all(promises);
    return config;
  })
  exportDatabaseTask;

  /**
   * Import a complete database dump as created by this.exportDatabase()
   *
   * Also available as a task: &#x60;indexedDb.importDatabaseTask.perform()&#x60;
   *
   * @method importDatabase
   * @param {Object} config A configuration object as created by this.exportDatabase()
   * @return {Promise}
   * @public
   */
  importDatabase(config) {
    let promise = this.importDatabaseTask.perform(config);
    this._addToPromiseQueue(promise);
    return promise;
  }

  @task(function* (config) {
    let { databaseName, version, stores, data } = config;

    log(&#x27;====================================&#x27;);
    log(&#x27;Importing database dump!&#x27;);

    log(&#x27;Dropping existing database...&#x27;);
    yield this.dropDatabaseTask.perform();

    log(&#x60;Setting up database ${databaseName} in version ${version}...&#x60;);
    let db = new Dexie(databaseName);
    db.version(version).stores(stores);

    log(&#x27;Opening database...&#x27;);
    yield openDb(db);

    let tables = Object.keys(data);
    while (tables.length) {
      let table = tables.shift();
      log(&#x60;Importing ${data[table].length} rows for ${table}...&#x60;);
      yield db[table].bulkPut(data[table]);
    }

    // This is closed here, don&#x27;t forget to call &#x27;setup&#x27; again, to do eventually necessary migrations
    yield closeDb(db);

    log(&#x27;Database import done!&#x27;);
  })
  importDatabaseTask;

  /**
   * Wait for all queued objects ot be resolved.
   * This will resolve when there are no open processes anymore.
   *
   * Also available as a task: &#x60;indexedDb.waitForQueueTask.perform()&#x60;
   *
   * @method waitForQueue
   * @return {Promise}
   * @public
   */
  waitForQueue() {
    return this.waitForQueueTask.perform();
  }

  @task(function* () {
    while (this._promiseQueue.length &gt; 0 || this._savePromise) {
      yield timeout(100);
    }
  })
  waitForQueueTask;

  /**
   * Get the queue and save everything in it in bulk.
   *
   * @method _bulkSave
   * @private
   */
  _bulkSave() {
    let { _saveQueue: saveQueue } = this;

    let promises = array();
    for (let i in saveQueue) {
      promises.push(this.add(i, saveQueue[i]));
      saveQueue[i] = array();
    }

    return Promise.all(promises, &#x27;indexedDb/_bulkSave&#x27;);
  }

  _logQuery(str, query) {
    if (this._shouldLogQuery) {
      // eslint-disable-next-line
      console.log(&#x60;[QUERY]: ${str}&#x60;, query);
    }
  }

  /**
   * Build a query for Dexie.
   *
   * This will try to find a matching index, and use it if possible.
   * It can also handle multi-indecies, if they have been specified and are supported.
   * If no matching index is found, it will fetch everything and try to filter it via JS.
   * Note that this is _much_ slower than querying by actual indecies, so you should definitely use that if possible!
   * If you are using multiple query arguments, and only one of them is found as index, it will query the database by this index
   * and then do the other queries via JS filter.
   *
   * Note that this will also auto-convert boolean query arguments to 1/0.
   *
   * @method _buildQuery
   * @param {String} type The model type to query
   * @param {Object} query The actual query
   * @return {Dexie.Collection}
   * @private
   */
  _buildQuery(type, query) {
    let { db, _supportsCompoundIndices: supportsCompoundIndices } = this;

    let keys = Object.keys(query);

    // Order of query params is important!
    let { schema } = db[type];
    let { indexes } = schema;

    // Only one, try to find a simple index
    if (keys.length === 1) {
      let key = keys[0];
      let index = indexes.find((index) =&gt; {
        let { keyPath } = index;
        return keyPath === key;
      });

      if (index) {
        this._logQuery(&#x60;Using index &quot;${key}&quot;&#x60;, query);
        let value = normalizeValue(query[key]);
        return db[type].where(key).equals(value);
      }
    }

    // try to find a fitting multi index
    // only if the client supports compound indices!
    if (keys.length &gt; 1 &amp;&amp; supportsCompoundIndices) {
      let multiIndex = indexes.find((index) =&gt; {
        let { keyPath } = index;

        // If keyPath is not set, not an array or not the same length as the keys, it&#x27;s not the correct one
        if (
          !keyPath ||
          getTypeOf(keyPath) !== &#x27;array&#x27; ||
          keyPath.length !== keys.length
        ) {
          return false;
        }

        // If one of the keys is not in the keyPath, return false
        return !keys.find((key) =&gt; !keyPath.includes(key));
      });

      // If a multi index is found, use it
      if (multiIndex) {
        let { keyPath, name: keyName } = multiIndex;
        let compareValues = array();

        keyPath.forEach((key) =&gt; {
          let value = normalizeValue(query[key]);
          compareValues.push(value);
        });

        this._logQuery(&#x60;Using compound index &quot;${keyPath}&quot;&#x60;, query);
        return db[type].where(keyName).equals(compareValues);
      }
    }

    // Else, filter manually
    // Try to find at least a single actual index, if possible...
    let whereKey = keys.find((key) =&gt; {
      return indexes.some((index) =&gt; {
        let { keyPath } = index;
        return keyPath === key;
      });
    });

    let whereKeyValue = whereKey ? normalizeValue(query[whereKey]) : null;
    let vanillaFilterKeys = keys.filter((key) =&gt; !whereKey || key !== whereKey);

    let collection = whereKey
      ? db[type].where(whereKey).equals(whereKeyValue)
      : db[type];

    if (whereKey) {
      this._logQuery(
        &#x60;Using index &quot;${whereKey}&quot; and vanilla filtering for ${vanillaFilterKeys.join(
          &#x27;, &#x27;
        )}&#x60;,
        query
      );
    } else {
      this._logQuery(&#x60;Using vanilla filtering&#x60;, query);
    }

    return collection.filter((item) =&gt; {
      return vanillaFilterKeys.every((key) =&gt; {
        return (
          normalizeValue(item.json.attributes[key]) ===
          normalizeValue(query[key])
        );
      });
    });
  }

  _mapItem(type, item) {
    let { indexedDbConfiguration } = this;

    return indexedDbConfiguration.mapItem(type, item);
  }

  _toString(val) {
    return &#x60;${val}&#x60;;
  }

  /**
   * Add a promise to the promise queue.
   * When the promise resolves or rejects, it will be removed from the promise queue.
   *
   * @method _addToPromiseQueue
   * @param {Promise} promise
   * @return {Promise}
   * @private
   */
  _addToPromiseQueue(promise) {
    let { _promiseQueue: promiseQueue } = this;

    let wrappedPromise = waitForPromise(promise);
    promiseQueue.pushObject(wrappedPromise);

    let removeObject = () =&gt; {
      promiseQueue.removeObject(wrappedPromise);
    };

    wrappedPromise.finally(removeObject);
    return wrappedPromise;
  }

  constructor() {
    super(...arguments);

    try {
      window.IDBKeyRange.only([1]);
    } catch (e) {
      this._supportsCompoundIndices = false;
    }
  }
}

async function openDb(db) {
  while (!db.isOpen()) {
    await db.open();
  }
  return db;
}

async function closeDb(db) {
  while (db.isOpen()) {
    await db.close();
  }
  return db;
}

function normalizeValue(value) {
  if (typeof value === &#x27;boolean&#x27;) {
    return value ? 1 : 0;
  }

  return value;
}

function log(str) {
  if (macroCondition(!isTesting())) {
    // eslint-disable-next-line no-console
    console.log(str);
  }
}

    </pre>
</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <script src="../assets/vendor/prettify/prettify-min.js"></script>
    <script>prettyPrint();</script>
    <script src="../assets/vendor/jquery/jquery.min.js"></script>
    <script src="../assets/vendor/jquery-ui/jquery-ui.min.js"></script>
    <script src="../assets/vendor/bootstrap/js/bootstrap.js"></script>
    <script src="../assets/vendor/github-slugger/slugger.js"></script>
    <script src="../assets/js/yuidoc-bootstrap.js"></script>
</body>
</html>
